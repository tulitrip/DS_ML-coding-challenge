# -*- coding: utf-8 -*-
"""Tulika_AIML_Assessment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hEGhZys3aQEjJWR043IzK9M623oD9WZR

Compare and explain the different approaches you might have considered. (In your notebook):

After trying some basic models like Naive Forecasting and some traditional ml models like linear regression and gradient boosting I finally settled on prophet.Prophet developed by Facebook is designed specifically for time-series forecasting it was an easier and quicker way to provide forecast for the given model.

Explain the final approach you have taken and why. (In your notebook):
I choose Prophet for time-series forecasting because it's specifically designed for such tasks, automatically handles seasonality, offers flexibility for customization, provides uncertainty estimates, and is easy to use. These factors make it a suitable and efficient choice for your forecasting needs.
"""

from google.colab import drive
drive.mount('/content/drive')

# Step 1: Data Understanding and Preparation
import pandas as pd

# Load the dataset

train_df = pd.read_excel('/content/drive/MyDrive/training.xlsx')
test_df = pd.read_excel('/content/drive/MyDrive/test.xlsx')

"""First intial steps are for basic EDA fucntionalities"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

print("Training Data:")
print(train_df.head())

print("\nTesting Data:")
print(test_df.head())

print("\nTraining Data Shape:", train_df.shape)
print("Testing Data Shape:", test_df.shape)

# Check data types and missing values in the training dataset
print("\nTraining Data Types:")
print(train_df.dtypes)
print("\nTraining Data Missing Values:")
print(train_df.isnull().sum())

print("\nTraining Data Summary Statistics:")
print(train_df.describe())



# Unique values in categorical columns
print(train_df['ProductType'].unique())
print(train_df['Manufacturer'].unique())
print(train_df['Area Code'].unique())
print(train_df['Sourcing Channel'].unique())

import matplotlib.pyplot as plt

# Assuming 'Month of Sourcing' is the time-related column in your training dataset
plt.figure(figsize=(12, 6))
plt.plot(train_df['Month of Sourcing'], train_df['Sourcing Cost'])
plt.xlabel('Month of Sourcing')
plt.ylabel('Sourcing Cost')
plt.title('Sourcing Cost Over Time (Training Data)')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability

# Adjust path chunk size and simplify threshold to prevent OverflowError
plt.rcParams['agg.path.chunksize'] = 1000  # Set a value greater than the number of data points
plt.rcParams['path.simplify_threshold'] = 0.01  # Adjust path simplification threshold as needed

plt.show()

print(test_df['ProductType'].unique())
print(test_df['Manufacturer'].unique())
print(test_df['Area Code'].unique())
print(test_df['Sourcing Channel'].unique())

"""this code is preprocessing the 'Sourcing Cost' column by handling missing values and outliers using winsorization.
it provides summary statistics to assess the impact of these preprocessing steps.
"""

import pandas as pd
from scipy.stats.mstats import winsorize

# Handle missing values in the 'Sourcing Cost' column for both training and testing DataFrames
train_df['Sourcing Cost'].fillna(train_df['Sourcing Cost'].median(), inplace=True)
test_df['Sourcing Cost'].fillna(test_df['Sourcing Cost'].median(), inplace=True)

# Winsorize the 'Sourcing Cost' column in both training and testing DataFrames to handle outliers
train_df['Sourcing Cost Winsorized'] = winsorize(train_df['Sourcing Cost'], limits=[0.05, 0.05])
test_df['Sourcing Cost Winsorized'] = winsorize(test_df['Sourcing Cost'], limits=[0.05, 0.05])

# Check the summary statistics before and after winsorization for both training and testing DataFrames
print("Training Data - Summary Statistics before Winsorization:")
print(train_df['Sourcing Cost'].describe())
print("\nTraining Data - Summary Statistics after Winsorization:")
print(train_df['Sourcing Cost Winsorized'].describe())

print("\n---------------------------------------------\n")

print("Testing Data - Summary Statistics before Winsorization:")
print(test_df['Sourcing Cost'].describe())
print("\nTesting Data - Summary Statistics after Winsorization:")
print(test_df['Sourcing Cost Winsorized'].describe())

# Check the data type of 'Sourcing Cost' column
print(train_df['Sourcing Cost'].dtype)

# Convert 'Sourcing Cost' column to numeric
train_df['Sourcing Cost'] = pd.to_numeric(train_df['Sourcing Cost'], errors='coerce')

# Ensure there are no NaN values after conversion
print(train_df['Sourcing Cost'].isnull().sum())

# Check the data types of all columns
print(train_df.dtypes)

!pip install prophet

from prophet import Prophet
import pandas as pd

# Data Preparation
train_df['Month of Sourcing'] = pd.to_datetime(train_df['Month of Sourcing'])
test_df['Month of Sourcing'] = pd.to_datetime(test_df['Month of Sourcing'])

# Prepare dataset for Prophet
train_prophet = train_df[['Month of Sourcing', 'Sourcing Cost']].copy()
train_prophet.rename(columns={'Month of Sourcing': 'ds', 'Sourcing Cost': 'y'}, inplace=True)

"""model training"""

# Model Training
model = Prophet()
model.fit(train_prophet)

# Forecasting for June 2021
future_dates = pd.DataFrame({'ds': pd.date_range(start='2021-06-01', end='2021-06-30')})
forecast = model.predict(future_dates)

# Display the forecasted values
print(forecast[['ds', 'yhat']])

# Visualization
fig = model.plot(forecast)

# Merge forecasted values with testing data
forecasted_values = forecast[['ds', 'yhat']]
forecasted_values['Month of Sourcing'] = forecasted_values['ds'].dt.strftime('%b-%y')
forecasted_values.drop(columns=['ds'], inplace=True)
forecasted_values.rename(columns={'yhat': 'Sourcing Cost'}, inplace=True)
test_df['Month of Sourcing'] = 'Jun-21'  # Assuming all dates in the test set are in June 2021

# Concatenate testing data with forecasted values
forecasted_test_data = pd.concat([test_df], axis=1)

# Rearrange columns to match the desired format
forecasted_test_data = forecasted_test_data[['ProductType', 'Manufacturer', 'Area Code', 'Sourcing Channel',
                                             'Product Size', 'Product Type', 'Month of Sourcing', 'Sourcing Cost']]

# Display the forecasted test data
print(forecasted_test_data)
forecasted_test_data.to_excel('forecastedjune.xlsx', index=False)

# Merge forecasted values with testing data
forecasted_test_data = pd.concat([test_df, forecasted_values], axis=1)

# Rearrange columns to match the desired format
forecasted_test_data = forecasted_test_data[['ProductType', 'Manufacturer', 'Area Code', 'Sourcing Channel',
                                             'Product Size', 'Product Type', 'Month of Sourcing', 'Sourcing Cost']]

# Display the forecasted test data
print(forecasted_test_data)

"""final sheet can be seen, /content/forecastedjune.xlsx is the forescasted excel sheet."""

